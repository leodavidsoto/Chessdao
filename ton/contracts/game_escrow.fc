;; ===============================================
;; ChessDAO Game Escrow Contract
;; ===============================================
;; 
;; Escrow contract for chess betting games.
;; Holds tokens from both players and releases to winner.
;; 
;; Flow:
;; 1. Creator deposits bet → game state = WAITING
;; 2. Opponent joins with matching bet → game state = ACTIVE
;; 3. Game ends → arbiter calls settle → winner gets pot
;; ===============================================

#include "stdlib.fc";

;; Game states
const int STATE_WAITING = 0;   ;; Waiting for opponent
const int STATE_ACTIVE = 1;    ;; Game in progress
const int STATE_SETTLED = 2;   ;; Game finished
const int STATE_CANCELLED = 3; ;; Game cancelled

;; Operation codes
const int op::create_game = 0x01;
const int op::join_game = 0x02;
const int op::settle_game = 0x03;
const int op::cancel_game = 0x04;
const int op::claim_refund = 0x05;
const int op::receive_jettons = 0x7362d09c; ;; transfer_notification

;; ===============================================
;; STORAGE LAYOUT
;; ===============================================
;; 
;; game_id:uint64            - Unique game identifier
;; state:uint8               - Current game state
;; creator:MsgAddress        - Player who created the game
;; opponent:MsgAddress       - Player who joined
;; bet_amount:uint128        - Bet amount per player
;; arbiter:MsgAddress        - Address that can settle games
;; jetton_wallet:MsgAddress  - This contract's jetton wallet
;; creator_deposited:uint1   - Has creator deposited?
;; opponent_deposited:uint1  - Has opponent deposited?
;; ===============================================

(int, int, slice, slice, int, slice, slice, int, int) load_data() inline {
    slice ds = get_data().begin_parse();
    return (
        ds~load_uint(64),      ;; game_id
        ds~load_uint(8),       ;; state
        ds~load_msg_addr(),    ;; creator
        ds~load_msg_addr(),    ;; opponent
        ds~load_coins(),       ;; bet_amount
        ds~load_msg_addr(),    ;; arbiter
        ds~load_msg_addr(),    ;; jetton_wallet
        ds~load_uint(1),       ;; creator_deposited
        ds~load_uint(1)        ;; opponent_deposited
    );
}

() save_data(int game_id, int state, slice creator, slice opponent, 
             int bet_amount, slice arbiter, slice jetton_wallet,
             int creator_deposited, int opponent_deposited) impure inline {
    set_data(begin_cell()
        .store_uint(game_id, 64)
        .store_uint(state, 8)
        .store_slice(creator)
        .store_slice(opponent)
        .store_coins(bet_amount)
        .store_slice(arbiter)
        .store_slice(jetton_wallet)
        .store_uint(creator_deposited, 1)
        .store_uint(opponent_deposited, 1)
        .end_cell());
}

;; ===============================================
;; HELPER FUNCTIONS
;; ===============================================

() send_jettons(slice to_address, int amount, slice jetton_wallet) impure inline {
    cell body = begin_cell()
        .store_uint(0xf8a7ea5, 32)  ;; op::transfer
        .store_uint(0, 64)          ;; query_id
        .store_coins(amount)        ;; amount
        .store_slice(to_address)    ;; destination
        .store_slice(to_address)    ;; response_destination
        .store_uint(0, 1)           ;; no custom_payload
        .store_coins(1)             ;; forward_ton_amount
        .store_uint(0, 1)           ;; no forward_payload
        .end_cell();
    
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(jetton_wallet)
        .store_coins(50000000)      ;; 0.05 TON for gas
        .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_ref(body)
        .end_cell();
    
    send_raw_message(msg, 1);
}

;; ===============================================
;; MESSAGE HANDLERS
;; ===============================================

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return ();
    }
    
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    
    if (flags & 1) {
        return (); ;; Ignore bounced
    }
    
    slice sender = cs~load_msg_addr();
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);
    
    (int game_id, int state, slice creator, slice opponent, 
     int bet_amount, slice arbiter, slice jetton_wallet,
     int creator_deposited, int opponent_deposited) = load_data();
    
    ;; ========== RECEIVE JETTONS (Deposit) ==========
    ;; Called when tokens are transferred to this contract
    if (op == op::receive_jettons) {
        int amount = in_msg_body~load_coins();
        slice from_address = in_msg_body~load_msg_addr();
        
        throw_unless(100, state == STATE_WAITING | state == STATE_ACTIVE);
        throw_unless(101, amount >= bet_amount);
        
        ;; Creator depositing
        if (equal_slices(from_address, creator) & (creator_deposited == 0)) {
            creator_deposited = 1;
            
            if (opponent_deposited == 1) {
                state = STATE_ACTIVE;
            }
            
            save_data(game_id, state, creator, opponent, bet_amount, 
                     arbiter, jetton_wallet, creator_deposited, opponent_deposited);
            return ();
        }
        
        ;; Opponent depositing
        if (equal_slices(from_address, opponent) & (opponent_deposited == 0)) {
            opponent_deposited = 1;
            
            if (creator_deposited == 1) {
                state = STATE_ACTIVE;
            }
            
            save_data(game_id, state, creator, opponent, bet_amount,
                     arbiter, jetton_wallet, creator_deposited, opponent_deposited);
            return ();
        }
        
        ;; Unknown sender - refund
        send_jettons(from_address, amount, jetton_wallet);
        return ();
    }
    
    ;; ========== SETTLE GAME ==========
    ;; Only arbiter can settle. Sends pot to winner.
    if (op == op::settle_game) {
        throw_unless(73, equal_slices(sender, arbiter));
        throw_unless(102, state == STATE_ACTIVE);
        
        slice winner = in_msg_body~load_msg_addr();
        
        ;; Winner must be creator or opponent
        throw_unless(103, equal_slices(winner, creator) | equal_slices(winner, opponent));
        
        ;; Send pot to winner (bet_amount * 2)
        send_jettons(winner, bet_amount * 2, jetton_wallet);
        
        save_data(game_id, STATE_SETTLED, creator, opponent, bet_amount,
                 arbiter, jetton_wallet, creator_deposited, opponent_deposited);
        return ();
    }
    
    ;; ========== CANCEL GAME ==========
    ;; Creator can cancel if opponent hasn't joined
    if (op == op::cancel_game) {
        throw_unless(73, equal_slices(sender, creator) | equal_slices(sender, arbiter));
        throw_unless(104, state == STATE_WAITING);
        
        ;; Refund creator if deposited
        if (creator_deposited == 1) {
            send_jettons(creator, bet_amount, jetton_wallet);
        }
        
        save_data(game_id, STATE_CANCELLED, creator, opponent, bet_amount,
                 arbiter, jetton_wallet, 0, 0);
        return ();
    }
    
    throw(0xffff);
}

;; ===============================================
;; GETTER METHODS
;; ===============================================

;; Get game state
(int, int, slice, slice, int, int, int) get_game_info() method_id {
    (int game_id, int state, slice creator, slice opponent, 
     int bet_amount, _, _, int creator_deposited, int opponent_deposited) = load_data();
    return (game_id, state, creator, opponent, bet_amount, creator_deposited, opponent_deposited);
}

;; Get total pot
int get_pot() method_id {
    (_, int state, _, _, int bet_amount, _, _, int cd, int od) = load_data();
    if (state != STATE_ACTIVE) {
        return 0;
    }
    return bet_amount * (cd + od);
}
